import times
import strutils
import parseutils
import tables
import macros
import timezones/private/binformat

# Future improvements:
#  - Put all transitions in an array[int, array[int, Transition]]
#  - Put names in a HashTable[string, int]
#  - In the timezone closure, only keep the tz index around.
#    Note that reading the transitions is gcsafe.

# type
#     DateTimeClass = enum
#         Unknown, Valid, Invalid, Ambiguous
# # Check C# for naming.
# proc isAmbiguous(tz: Timezone, ndt: NaiveDateTime): bool = discard
# proc isValid(tz: Timezone, ndt: NaiveDateTime): bool = discard
# proc hasDst(tz: Timezone): bool = discard
# proc classify(tz: Timezone, ndt: NaiveDateTIme): DateTimeClass = discard

# xxx the silly default path is because it's relative to "binformat.nim"
when defined(JS):
    const embedTzdb {.strdefine.} = "../../bundled_tzdb_files/2017c.json.bin"
else:    
    const embedTzdb {.strdefine.} = "../../bundled_tzdb_files/2017c.bin"

const read = binformat.staticReadFromFile embedTzdb

when read.status == rsSuccess:
    const staticDatabase = read.payload
elif read.status == rsFileDoesNotExist:
    {.fatal: "Failed to read tzdb file: '" &
        embedTzdb & "' does not exist.".}
elif read.status == rsIncorrectFormatVersion:
    {.fatal: "Found unexpected tzdb format version in '" &
        embedTzdb & "'.\n" &
        "Either the file is corrupt, " &
        "it's generated by an old version of fetchtzdb, " &
        "or it's not a tzdb file at all. " &
        "You need to regenerate the tzdb file.".}
elif read.status == rsExpectedJsonFormat:
    {.fatal: "The file '" & tembedTzdb & "' is using the " &
        "binary format, which is not supported on the JS backend.\n" &
        "To use a custom tzdb file on the JS backend it must be created " &
        "using the `--json` flag.".}

macro createCountryCodeEnum(countryCodes: static[seq[string]]): untyped =
    var enumValues = newSeq[NimNode]()
    
    for cc in countryCodes:
        enumValues.add newIdentNode($cc)

    nnkTypeSection.newTree(
        nnkTypeDef.newTree(
            nnkPostfix.newTree(
                newIdentNode("*"),
                newIdentNode("CountryCode")
            ),
            newEmptyNode(),
            nnkEnumTy.newTree(@[newEmptyNode()] & enumValues)
        )
    )

createCountryCodeEnum(staticDatabase.ccs)
let timezoneDatabase = finalize[CountryCode](staticDatabase)

const v = $staticDatabase.version
const TzdbMetadata* = (
    version: v,
    startYear: staticDatabase.startYear,
    endYear: staticDatabase.endYear
) ## Meta data about the tzdb file.
  ## These values will depend on what parameters was used when creating the tzdb file.

proc countries*(tzname: string): set[CountryCode] =
    ## Get a list of countries that are known to use ``tzname``.
    ## The result might be empty. Note that some countries use
    ## multiple timezones.
    runnableExamples:
        doAssert countries"Europe/Stockholm" == { SE }
        doAssert countries"Asia/Bangkok" == {TH, KH, LA, VN}
    let id = timezoneDatabase.idByName[tzname]
    result = timezoneDatabase.timezones[id].ccs

proc countries*(tz: Timezone): set[CountryCode] {.inline.} =
    ## Shorthand for ``countries(tz.name)``
    tz.name.countries

proc tzNames*(country: CountryCode): seq[string] =
    ## Get a list of timezone names known to be used by ``country``.
    runnableExamples:
        doAssert SE.tznames == @["Europe/Stockholm"]
        doAssert VN.tznames == @["Asia/Bangkok", "Asia/Ho_Chi_Minh"]
    let ids = timezoneDatabase.idsByCountry[country]
    result = newSeq[string](ids.len)
    for idx, id in ids:
        result[idx] = timezoneDatabase.timezones[id].name

template binarySeach(transitions: seq[Transition],
                     field: untyped, t: Time): int =

    var lower = 0
    var upper = transitions.high
    while lower < upper:
        var mid = (lower + upper) div 2
        if transitions[mid].field >= t.toUnix:
            upper = mid - 1
        elif lower == mid:
            break
        else:
            lower = mid
    lower

proc initTimezone(name: string, tz: RuntimeTimezoneData): Timezone =
    # xxx it might be bad to keep the transitions in the closure,
    # since they're so many.
    # Probably better if the closure keeps a small reference to the index in the
    # shared db.
    proc zoneInfoFromTz(adjTime: Time): ZonedTime {.locks: 0.} =
        let index = tz.transitions.binarySeach(startAdj, adjTime)
        let transition = tz.transitions[index]

        if index < tz.transitions.high:
            let current = tz.transitions[index]
            let next = tz.transitions[index + 1]
            let offsetDiff = next.utcOffset - current.utcOffset
            # This means that we are in the invalid time between two transitions
            if adjTime.toUnix > next.startAdj - offsetDiff:
                result.isDst = next.isDst
                result.utcOffset = -next.utcOffset
                result.adjTime = adjTime +
                    initDuration(seconds = offsetDiff)
                return

        result.isDst = transition.isDst
        result.utcOffset = -transition.utcOffset
        result.adjTime = adjTime

        if index != 0:
            let prevTransition = tz.transitions[index - 1]
            let offsetDiff = transition.utcOffset - prevTransition.utcOffset
            let adjUnix = adjTime.toUnix

            if offsetDiff < 0:
                # Times in this interval are ambiguous
                # Resolved by picking earlier transition
                if transition.startAdj <= adjUnix and
                        adjUnix < transition.startAdj - offsetDiff:
                    result.isDst = prevTransition.isDst
                    result.utcOffset = -prevTransition.utcOffset
                
    proc zoneInfoFromUtc(time: Time): ZonedTime {.locks: 0.} =
        let transition = tz.transitions[tz.transitions.binarySeach(startUtc, time)]
        result.isDst = transition.isDst
        result.utcOffset = -transition.utcOffset
        result.adjTime = time + initDuration(seconds = transition.utcOffset)

    result.name = name
    result.zoneInfoFromTz = zoneInfoFromTz
    result.zoneInfoFromUtc = zoneInfoFromUtc

proc resolveTimezone(name: string): tuple[exists: bool, candidate: string] =
    var bestCandidate: string
    var bestDistance = high(int)
    for tz in staticDatabase.timezones:
        let candidate = tz.name
        if candidate == name:
            return (true, "")
        else:
            let distance = editDistance(candidate, name)
            if distance < bestDistance:
                bestCandidate = candidate
                bestDistance = distance
    return (false, bestCandidate)

proc tz*(name: string): Timezone {.inline.} =
    ## Create a timezone using a name from the IANA timezone database.
    runnableExamples:
        import times
        let sweden = tz"Europe/Stockholm"
        let dt = initDateTime(1, mJan, 1850, 00, 00, 00, sweden)
        doAssert $dt == "1850-01-01T00:00:00+01:12"
    let id = timezoneDatabase.idByName[name]
    result = initTimezone(name, timezoneDatabase.timezones[id])

proc tz*(name: static[string]): Timezone {.inline.} =
    ## Create a timezone using a name from the IANA timezone database.
    ## Validates the timezone name during compile time.
    runnableExamples:
        import times
        let sweden = tz"Europe/Stockholm"
        let dt = initDateTime(1, mJan, 1850, 00, 00, 00, sweden)
        doAssert $dt == "1850-01-01T00:00:00+01:12"
    const resolved = name.resolveTimezone
    when not resolved.exists:
        {.fatal: "Timezone not found: '" & name &
            "'.\nDid you mean '" & resolved.candidate & "'?".}

    let id = timezoneDatabase.idByName[name]    
    result = initTimezone(name, timezoneDatabase.timezones[id])

proc initTimezone(name: string, offset: int): Timezone =

    proc zoneInfoFromTz(adjTime: Time): ZonedTime {.locks: 0.} =
        result.isDst = false
        result.utcOffset = offset
        result.adjTime = adjTime

    proc zoneInfoFromUtc(time: Time): ZonedTime {.locks: 0.}=
        result.isDst = false
        result.utcOffset = offset
        result.adjTime = time - initDuration(seconds = offset)

    result.name = name
    result.zoneInfoFromTz = zoneInfoFromTz
    result.zoneInfoFromUtc = zoneInfoFromUtc

proc staticTz*(hours, minutes, seconds: int = 0): Timezone {.noSideEffect.} =
    ## Create a timezone using a static offset from UTC.
    runnableExamples:
        import times
        let tz = staticTz(hours = -2, minutes = -30)
        let dt = initDateTime(1, mJan, 2000, 12, 00, 00, tz)
        doAssert $dt == "2000-01-01T12:00:00+02:30"

    let offset = hours * 3600 + minutes * 60 + seconds
    let hours = offset div 3600
    var rem = offset mod 3600
    let minutes = rem div 60
    let seconds = rem mod 60
    
    let offsetStr = abs(hours).intToStr(2) &
        ":" & abs(minutes).intToStr(2) & 
        ":" & abs(seconds).intToStr(2)
    
    let name =
        if offset > 0:
            "STATIC[-" & offsetStr & "]"
        else:
            "STATIC[+" & offsetStr & "]"            

    result = initTimezone(name, offset)
