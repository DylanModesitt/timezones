import times
import strutils
import tables
import macros
import options
import private/binformat

export binformat.Coordinates

# TODO: Add Etc/UTC to element 0 in timezone db

proc `$`*(coords: Coordinates): string =
    let latD = if coords.lat.deg < 0: 'S' else: 'N'
    let lonD = if coords.lon.deg < 0: 'W' else: 'E'
    "$1° $2′ $3″ $4 $5° $6′ $7″ $8".format(
        coords.lat.deg, coords.lat.min, coords.lat.sec, latD,
        coords.lon.deg, coords.lon.min, coords.lon.sec, lonD
    )

template nodoc(fun: untyped): untyped =
    when not defined(nimsuggest) and not defined(nimdoc):
        fun

# type
#     DateTimeClass = enum
#         Unknown, Valid, Invalid, Ambiguous
# # Check C# for naming.
# proc isAmbiguous(tz: Timezone, ndt: NaiveDateTime): bool = discard
# proc isValid(tz: Timezone, ndt: NaiveDateTime): bool = discard
# proc hasDst(tz: Timezone): bool = discard
# proc classify(tz: Timezone, ndt: NaiveDateTIme): DateTimeClass = discard

# xxx the silly default path is because it's relative to "binformat.nim"
when not defined(nimsuggest):
    when defined(JS):
        const embedTzdb {.strdefine.} = "../../bundled_tzdb_files/2017c.json.bin"
    else:    
        const embedTzdb {.strdefine.} = "../../bundled_tzdb_files/2017c.bin"

const read = binformat.staticReadFromFile embedTzdb

when read.status == rsSuccess:
    const staticDatabase = read.payload
elif read.status == rsFileDoesNotExist:
    {.fatal:
        "\nFailed to read tzdb file: '$1' does not exist." % embedTzdb.}
elif read.status == rsIncorrectFormatVersion:
    {.fatal:
        ("\nFound unexpected tzdb format version in '$1'\n" % embedTzdb) &
        "Either the file is corrupt, it's generated by an old " &
        "version of fetchtzdb, or it's not a tzdb file at all.\n" &
        "You need to regenerate the tzdb file.".}
elif read.status == rsExpectedJsonFormat:
    {.fatal:
        ("\nThe file '$1' is using the binary format, " % embedTzdb) &
        "which is not supported on the JS backend.\n" &
        "To use a custom tzdb file on the JS backend it must be created " &
        "using the `--json` flag.".}

macro createCountryCodeEnum(countryCodes: static[seq[string]]): untyped =
    var enumValues = newSeq[NimNode]()
    
    for cc in countryCodes:
        enumValues.add newIdentNode($cc)

    nnkTypeSection.newTree(
        nnkTypeDef.newTree(
            nnkPostfix.newTree(
                newIdentNode("*"),
                newIdentNode("CountryCode")
            ),
            newEmptyNode(),
            nnkEnumTy.newTree(@[newEmptyNode()] & enumValues)
        )
    )

createCountryCodeEnum(staticDatabase.ccs)
const nTimezones = staticDatabase.timezones.len
let timezoneDatabase = finalize[CountryCode, nTimezones](staticDatabase)

const v = $staticDatabase.version
const TzdbMetadata* = (
    version: v,
    startYear: staticDatabase.startYear,
    endYear: staticDatabase.endYear
) ## Meta data about the tzdb file.
  ## These values will depend on what parameters was used when creating the tzdb file.

proc resolveTimezone(name: string): tuple[candidate: string,
                                          candidateDistance: int] =
    var bestCandidate: string
    var bestDistance = high(int)
    for tz in staticDatabase.timezones:
        let candidate = tz.name
        if candidate == name:
            return (name, 0)
        else:
            let distance = editDistance(candidate, name)
            if distance < bestDistance:
                bestCandidate = candidate
                bestDistance = distance
    return (bestCandidate, bestDistance)

proc getId(tzname: string): TimezoneId {.inline.} =
    # TODO: Use getOrDefault instead when PR is merged
    if tzname in timezoneDatabase.idByName:
        result = timezoneDatabase.idByName[tzname]
    else:
        raise newException(ValueError, "Timezone not found: '$1'" % tzname)

template getIdStatic(): untyped {.dirty.} =
    const resolved = tzname.resolveTimezone
    when resolved.candidateDistance in 1..3:
        {.error:
            "Timezone not found: '" & tzname & "'.\n" &
            "Did you mean '" & resolved.candidate & "'?".}
    elif resolved.candidateDistance > 3:
        {.error:
            "Timezone not found: '" & tzname & "'.\n"}

    timezoneDatabase.idByName[tzname]

proc countries*(tzname: string): set[CountryCode] =
    ## Get a list of countries that are known to use ``tzname``.
    ## The result might be empty. Note that some countries use
    ## multiple timezones.
    runnableExamples:
        doAssert countries"Europe/Stockholm" == { SE }
        doAssert countries"Asia/Bangkok" == { TH, KH, LA, VN }
    let id = getId(tzname)
    result = timezoneDatabase.timezones[id].ccs

proc countries*(tzname: static[string]): set[CountryCode] {.nodoc.} =
    let id = getIdStatic()
    result = timezoneDatabase.timezones[id].ccs

proc countries*(tz: Timezone): set[CountryCode] {.inline.} =
    ## Shorthand for ``countries(tz.name)``
    tz.name.countries

proc tzNames*(country: CountryCode): seq[string] =
    ## Get a list of timezone names for timezones
    ## known to be used by ``country``.
    runnableExamples:
        doAssert SE.tznames == @["Europe/Stockholm"]
        doAssert VN.tznames == @["Asia/Bangkok", "Asia/Ho_Chi_Minh"]
    let ids = timezoneDatabase.idsByCountry[country]
    result = newSeq[string](ids.len)
    for idx, id in ids:
        result[idx] = timezoneDatabase.timezones[id].name

proc locationImpl(id: TimezoneId): Option[Coordinates] =
    let tz = timezoneDatabase.timezones[id]
    # `RuntimeTimezoneData` should probably store `position` as
    # an `Option`, but (0, 0) is in the middle of the ocean so it doesn't
    # really matter.
    var default: Coordinates
    if tz.position != default:
        result = some(tz.position)

proc location*(tzname: string): Option[Coordinates] =
    ## Get the coordinates of a timezone. This is generally the position
    ## of the city in the timezone name.
    ## E.g ``location"Europe/Stockholm"`` will give the the coordinates
    ## of Stockholm, the capital of Sweden.
    ##
    ## Note that this is not defined for all timezones in the tzdb database,
    ## so this proc returns an ``Option`` when there is no position available.
    ## However, if the timezone name is not found, then a ``ValueError`` will
    ## be raised.
    runnableExamples:
        import options
        doAssert $(location"Europe/Stockholm") == r"Some(59° 20′ 0″ N 18° 3′ 0″ E)"
        # doAssert $(location"Etc/UTC") == "None"
    let id = getId(tzname)
    locationImpl(id)

proc location*(tzname: static[string]): Option[Coordinates] {.nodoc.} =
    let id = getIdStatic()
    locationImpl(id)

template binarySeach(transitions: seq[Transition],
                     field: untyped, t: Time): int =

    var lower = 0
    var upper = transitions.high
    while lower < upper:
        var mid = (lower + upper) div 2
        if transitions[mid].field >= t.toUnix:
            upper = mid - 1
        elif lower == mid:
            break
        else:
            lower = mid
    lower

proc initTimezone(tzname: string, tz: RuntimeTimezoneData): Timezone =
    # xxx it might be bad to keep the transitions in the closure,
    # since they're so many.
    # Probably better if the closure keeps a small reference to the index in the
    # shared db.
    proc zoneInfoFromTz(adjTime: Time): ZonedTime {.locks: 0.} =
        let index = tz.transitions.binarySeach(startAdj, adjTime)
        let transition = tz.transitions[index]

        if index < tz.transitions.high:
            let current = tz.transitions[index]
            let next = tz.transitions[index + 1]
            let offsetDiff = next.utcOffset - current.utcOffset
            # This means that we are in the invalid time between two transitions
            if adjTime.toUnix > next.startAdj - offsetDiff:
                result.isDst = next.isDst
                result.utcOffset = -next.utcOffset
                result.adjTime = adjTime +
                    initDuration(seconds = offsetDiff)
                return

        result.isDst = transition.isDst
        result.utcOffset = -transition.utcOffset
        result.adjTime = adjTime

        if index != 0:
            let prevTransition = tz.transitions[index - 1]
            let offsetDiff = transition.utcOffset - prevTransition.utcOffset
            let adjUnix = adjTime.toUnix

            if offsetDiff < 0:
                # Times in this interval are ambiguous
                # Resolved by picking earlier transition
                if transition.startAdj <= adjUnix and
                        adjUnix < transition.startAdj - offsetDiff:
                    result.isDst = prevTransition.isDst
                    result.utcOffset = -prevTransition.utcOffset
                
    proc zoneInfoFromUtc(time: Time): ZonedTime {.locks: 0.} =
        let transition = tz.transitions[tz.transitions.binarySeach(startUtc, time)]
        result.isDst = transition.isDst
        result.utcOffset = -transition.utcOffset
        result.adjTime = time + initDuration(seconds = transition.utcOffset)

    result.name = tzname
    result.zoneInfoFromTz = zoneInfoFromTz
    result.zoneInfoFromUtc = zoneInfoFromUtc

proc tz*(tzname: string): Timezone {.inline.} =
    ## Create a timezone using a name from the IANA timezone database.
    runnableExamples:
        import times
        let sweden = tz"Europe/Stockholm"
        let dt = initDateTime(1, mJan, 1850, 00, 00, 00, sweden)
        doAssert $dt == "1850-01-01T00:00:00+01:12"
   
    let id = getId(tzname)
    result = initTimezone(tzname, timezoneDatabase.timezones[id])

proc tz*(tzname: static[string]): Timezone {.inline, nodoc.} =
    let id = getIdStatic()
    result = initTimezone(tzname, timezoneDatabase.timezones[id])

proc initTimezone(tzname: string, offset: int): Timezone =

    proc zoneInfoFromTz(adjTime: Time): ZonedTime {.locks: 0.} =
        result.isDst = false
        result.utcOffset = offset
        result.adjTime = adjTime

    proc zoneInfoFromUtc(time: Time): ZonedTime {.locks: 0.}=
        result.isDst = false
        result.utcOffset = offset
        result.adjTime = time - initDuration(seconds = offset)

    result.name = tzname
    result.zoneInfoFromTz = zoneInfoFromTz
    result.zoneInfoFromUtc = zoneInfoFromUtc

proc staticTz*(hours, minutes, seconds: int = 0): Timezone {.noSideEffect.} =
    ## Create a timezone using a static offset from UTC.
    runnableExamples:
        import times
        let tz = staticTz(hours = -2, minutes = -30)
        let dt = initDateTime(1, mJan, 2000, 12, 00, 00, tz)
        doAssert $dt == "2000-01-01T12:00:00+02:30"

    let offset = hours * 3600 + minutes * 60 + seconds
    let hours = offset div 3600
    var rem = offset mod 3600
    let minutes = rem div 60
    let seconds = rem mod 60
    
    let offsetStr = abs(hours).intToStr(2) &
        ":" & abs(minutes).intToStr(2) & 
        ":" & abs(seconds).intToStr(2)
    
    let tzname =
        if offset > 0:
            "STATIC[-" & offsetStr & "]"
        else:
            "STATIC[+" & offsetStr & "]"            

    result = initTimezone(tzname, offset)
